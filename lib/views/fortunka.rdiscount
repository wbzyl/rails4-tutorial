#### {% title "Fortunka v1.0" %}

# „Fortunka” v1.0

Jednym ze sprawdzonych sposobów kontynuacji rozpoczętego projektu
jest rozpoczęcie go od nowa. I tak zrobimy. Dlaczego?

{%= image_tag "/images/head-element.png", :alt => "[source: http://diveintohtml5.org/]" %}<br>
(źródło M. Pilgrim. <a href="http://diveintohtml5.org/">Dive into HTML5</a>)

Tym razem nie skorzystamy z generatora „scaffold”.
Użyjemy generatora „resource”. Dlaczego?

Na początek wygenerujemy kod dla zasobu (ang. *resource*) *fortune*:

    rails generate resource fortune body:text

Co wygenerował generator?

Teraz jest czas na wykonanie migracji:

    rake db:migrate

W bazie nie ma jeszcze fortunek. Na tym etapie pisania aplikacji, do
bazy możemy dodać kilka fortunek na dwa sposoby:

* dodając je z konsoli
* wpisując je w pliku *db/seed.rb* i wykonując polecenie `rake seed`

Zróbmy to! Oczywiście, w gotowych aplikacjach rekordy do bazy dodajemy
korzystając z formularzy.

Następne rzeczy do zrobienia to:

* w pliku *config/routes.rb* ustawiamy domyślną stronę naszej aplikacji
* usuwamy plik *public/index.html*
* uruchamiamy serwer *thin*

Teraz możemy obejrzeć jak działa nasza aplikacja w środowisku
„development”.

Na koniec, obejrzmy jeszcze raz routing aplikacji:

    rake routes


## Kontroler

Generator utworzył plik *app/controllers/fortunes_controller.rb*.
zawierający pusty kontroler *FortunesController*.
*FortunesController* jest podklasą *ApplicationController*.

<blockquote>
 <h2>Rails 3 controllers</h2>
 <ul>
   <li>{%= link_to "nifty:scaffold", "/rails3/nifty-generators/comments_controller.rb" %}
   <li>{%= link_to "scaffold", "/rails3/scaffold/posts_controller.rb" %}
   <li>{%= link_to "respond_with", "/rails3/respond-with/fortunes_controller.rb" %}
 </ul>
</blockquote>

Każdy *resource controller* musi definiować **7 metod** o nazwach:

* *index*, *show*
* *new*, *create*
* *edit*, *update*
* *destroy*

Przykładowe implementacje można podejrzeć klikając linki po prawej.


## Akcje i szablony

Zwyczajowo *index* kojarzymy kompletną listę zasobów.

Uruchamiamy serwer www i wchodzimy na stronę z fortunkami:

    http://localhost:3000/fortunes

Co powinno się wydarzyć?

    Unknown action
    The action 'index' could not be found for FortunesController

Oznacza to, że powinniśmy napisać metodę *index*.

    :::ruby app/controllers/fortunes_controller.rb
    class FortunesController < ApplicationController
      respond_to :html
      def index
        @fortunes = Fortune.order("created_at desc")
        respond_with @fortunes
      end
    end

Więcej info o parze **respond_to** i **respond_with**:

* [Controllers in Rails 3](http://asciicasts.com/episodes/224-controllers-in-rails-3)
* [ActionController::Responder](http://github.com/rails/rails/blob/master/actionpack/lib/action_controller/metal/responder.rb)
* [One in Three: Inherited Resources, Has Scope and Responders](http://blog.plataformatec.com.br/tag/respond_with/)
  – zawiera opis *FlashResponder* (korzysta z **I18N**) oraz *HttpCacheResponder*

Odświeżamy stronę:

    http://localhost:3000/fortunes

Teraz serwer zgłasza wyjątek i odpowiada (*response*) komunikatem
o błędzie:

    Action Controller: Exception caught

    Template is missing
    Missing template fortunes/index with
      {:locale=>[:en, :en], :handlers=>[:builder, :rjs, :erb, :rhtml, :rxml],
      :formats=>[:html]} in view paths ".../app/views"

Nie pozostaje nam nic innego jak utworzyć szablon **powiązany**
z metodą *index*:

    :::html_rails app/views/fortunes/index.html.erb
    <h1>Fortunki</h1>
    <% @fortunes.each do |fortune| %>
    <p><%= fortune.body %></p>
    <% end %>

Jeszcze raz wchodzimy na stronę *index*. Teraz powinniśmy zobaczyć
widok wygenerowany z powyższego szablonu.

Powyżej mamy przykład szablonu *ERB* (ang. *embeded ruby*).

Co może oznaczać zwrot: **convention over configuration**?
Co to jest **ORM** – mapowanie obiektów na relacje
i relacji na obiekty?


### Tworzymy szablon „new” i metodę „new”

Jest obojętne czy najpierw utworzymy szablon, a później
metodę metodę powiązaną z tym szablonem czy odwrotnie.

Teraz, dla przykładu zaczniemy od szablonu *new.html.erb*.
Szablon powinien zawierać formularz umożliwiający
wpisanie nowej fortunki.

    :::html_rails app/views/fortunes/new.html.erb
    <h1>Nowa fortunka</h1>
    <%= form_for(Fortune.new) do |form| %>
    <p>
      <%= form.text_area :body %><br/>
      <%= form.submit %>
    <p>
    <% end %>

Powyżej korzystamy z **metody pomocniczej** (ang. *helper method*)
o nazwie *form_for*.

Ponieważ korzystamy z routingu REST, więc aby utworzyć
nową fortunkę wchodzimy na następujący url:

    http://localhost:3000/fortunes/new

Widzimy stronę z formularzem. Kilkamy przycisk *Create Fortune*.
Daje to następujący błąd:

    Unknown action
    The action 'create' could not be found for FortunesController

**Oczywiście** oznacza to, że powinniśmy zaimplementować metodę
*create*:

    :::ruby app/controllers/fortunes_controller.rb
    def create
      @fortune = Fortune.create(params[:fortune])
      respond_with @fortune # odpowiadamy polimorficznie
    end

Dlaczego wykonujemy *redirect_to*? Co oznacza tutaj *polimorficznie*?

Na razie zakładamy, że użytkownik nie oszukuje i wpisuje w formularz
to co jest proszony, a nie na przykład złośliwy kod.
Walidacją tego co wpisuje użytkownik zajmiemy się później.

Po kliknięciu przycisku „Create Fortune”, nowa fortunka
jest zapisywana w tabeli, a my zostajemy przekierowani na stronę
*show*, której nie ma:

    Unknown action
    The action 'show' could not be found for FortunesController

Nie napisaliśmy też metody *show*. Robimy to teraz.

Czytamy to co zostało wypisane na konsoli i piszemy metodę *show*:

    :::ruby app/controllers/fortunes_controller.rb
    def show
      @product = Product.find(params[:id])
      respond_with @product # odpowiadamy polimorficznie
    end

Szablon też piszemy „od ręki”:

    :::html_rails app/views/fortunes/show.html.erb
    <p>
      <b>Body:</b>
      <%= @fortune.body %>
    </p>


## Poprawki w layoucie

Zwyczajowo, po zapisaniu rekordu w bazie, na stronie na którą
zostajemy przekierowani, jest wyświetlany komunikat w stylu:
*Utworzono nowy rekord Fortune*.
Railsy do wyświetlania takich komunikatów korzystają z **flash messages**
Szablon do wyświetlania flash messages umieszczamy layoucie.

Sprawdzamy, czy te rzeczy działają w Frtunce v0.0.  Kopiujemy je do
Fortunki v1.0.  Czy można to jakoś zautomatyzować? Tak, przynajmniej
częściowo, zobacz

    rails new -h

opcja *template*.


## Responders

Problem:

* gdzie wpisać komunikaty flash?
* co z i18n?

Eleganckie rozwiązanie obu probelmów przedstawił
[José Valim](http://blog.plataformatec.com.br/tag/respond_with/).

Zaczynamy od:

    rails destroy controller fortune

Następnie dopisujemy gem do *Gemfile*:

    gem 'responders'

i wykonujemy:

    bundle install

Teraz możemy skorzystać z nowych generatorów:

    rails generate responders:install
    rails generate responders_controller fortune

Oooops! Drugi generator nadpisał utworzone przez nas pliki. Teraz
czeka nas poprawianie widoków.


### Konsola

Zacznijmy od przyjrzenia się jak działa **ORM** na konsoli:

    :::ruby
    Fortune.find_by_id 1
    Fortune.find 1
    Fortune.find 1, 4
    Fortune.find [1, 4]
    f = Fortune.find(1)
    f.update_attributes :updated_at => Time.now, :body => 'Hi!'

### Szablon dla new i edit

Szablon dla metody *edit* różni się
tylko nagłówkiem H1 od szablonu dla *new*.

    :::html_rails app/views/fortunes/edit.html.erb
    <%= title "Edycja fortunki" %>
    <%= form_for @fortune do |f| %>
    <p>
      <%= f.text_area :body %><br>
      <%= f.submit %>
    <p>
    <% end %>

Uwaga: metoda pomocnicza *title* jest zdefiniowana w pliku
*app/helpers/layout_helper.rb* wygenerowanym przez generator
nifty:layout.

Pytanie: jak można wyjaśnić, że napis na przycisku *submit* jest *New
Fortune* albo *Update Fortune*? Co decyduje o tym jaki napis jest na
przycisku?

Odpowiedź: Napisy, np. na przycisku submit, można samemu zdefiniować.
Tłumaczenia wpisujemy w jednym pliku albo w kilku
plikach. Pliki umieszczamy w katalogu *config/locales*.

Tak wygląda plik z polskimi tłumaczeniami dla komunikatów
wypisywanych przez *Responders*:

    :::yaml config/locales/responders.pl.yml
    pl:
      flash:
        actions:
          create:
            notice: '%{resource_name} was successfully utworzono.'
          update:
            notice: '%{resource_name} was successfully uaktualniono.'
          destroy:
            notice: '%{resource_name} was successfully usunięto.'
            alert: '%{resource_name} could not be usunąć.'

A tak to wygląda dla przycisku *Submit*:

    :::yaml config/locales/models.pl.yml
    pl:
      helpers:
        submit:
          create: "Utwórz %{model}"
          update: "Uaktualnij %{model}"


### Szablony częściowe

Generator rozwiązał problem powtórzonego fragmentu kodu
w naszych szablonach *new* i *edit*:

    :::ruby app/controllers/fortunes_controller.rb
    def new
      @fortune = Fortune.new
    end

Teraz, jeśli w szablonie dla *new* podmienimy *Fortune.new* na
*@fortune*, to kod formularza będzie taki sam w obu szablonach.

Co to jest refaktoryzacja?

Ciąg dalszy refaktoryzacji: usuwamy kod formularza z szablonów
i przenosimy go do szablonu *_form.html.erb*:

    :::html_rails app/views/fortunes/_form.html.erb
    <%= form_for @fortune do |f| %>
    <p>
      <%= f.text_area :body, :rows => 4 %><br>
      <%= f.submit %>
    <p>
    <% end %>

Zamiast usuniętego kodu wpisujemy w szablonach:

    :::html_rails
    <%= render 'form' %>

Szablon *_form.html.erb* nazywamy szablonem częściowym (ang. *partial template*).

Co to jest zasada DRY – Don’t repeat yourself.
Dlaczego „osuszanie” kodu jest ważne?


## Linkujemy widoki

W wygenerowanych szablonach generator wstawił odsyłacze.
Na przykład w widoku *index*:

    :::html_rails app/views/fortunes/index.html.erb
    <% @fortunes.each do |fortune| %>
    <p>
     <%= fortune.body %>
     <%= link_to "Edit", edit_fortune_path(fortune) %>
    </p>
    <% end %>
    <p><%= link_to "New Fortune", new_fortune_path %></p>

Wejdźmy na stronę:

    htttp://localhost:3000/fortunes

i sprawdźmy czy linki działają. Klikamy w jakikolwiek link 'Edit'.
Działa?

Przy okazji, zwróćmy uwagę, że metody *update* i *create* nie mają
powiązanych widoków.


### Usuwanie rekordów z tabel

W aktualnej wersji można utworzyć „pustą” fortunkę. Jak? Klikamy link
'New Fortune', następnie przycisk 'New Fortune'.
Oczywiście nie ma sensu umieszczanie pustych fortunek w bazie.

Na następnym wykładzie zaimplementujemy mechanizm zabezpieczający
przed zapisywaniem pustych fortunek w tabeli *fortunes* (walidacja).

Teraz zajmiemy się usuwaniem pustych fortunek z bazy.

    :::html_rails app/views/fortunes/index.html.erb
    <% @fortunes.each do |fortune| %>
    <p>
     <%= fortune.body %>
     <%= link_to "Edit", edit_fortune_path(fortune) %>
     <%= link_to "Delete", fortune_path(fortune), :confirm = "Are you sure?", :method => :delete %>
    </p>
    <% end %>
    <%= link_to "New Fortune", new_fortune_path %>


### Pozostała tylko implementacja *show*

Został tylko do omówienia widok *show* i powiązana z nim metoda
kontrolera.

    :::html_rails app/views/fortunes/show.html.erb
    <h1>Fortunka #<%= @fortune.id %></h1>
    <p>
      <%= @fortune.body %>
    </p>
    <p><%= link_to "All Fortunes", fortunes_path %></p>

Kontroler:

    :::ruby app/controllers/fortunes_controller.rb
    def show
      @fortune = Fortune.find(params[:id])
      respond_with @fortune
    end

W widoku *index* dopisujemy link:

    :::html_rails app/views/fortunes/index.html.erb
    <%= fortune.body %>
    <%= link_to "Show", fortune_path(fortune) %>

**Inne propozycje olinkowania zasobów?**


## Atom

Dopisujemy do kontrolera (z formatu :js skorzystamy go później):

    respond_to :html, :atom, :js

Widok:

    :::ruby app/views/fortunes/index.atom.builder
    atom_feed do |feed|
      feed.title "Moje Fortunki"
      feed.updated @fortunes.first.updated_at
      @fortunes.each do |fortune|
        feed.entry(fortune) do |entry|
          entry.content fortune.body, :type => "html"
        end
      end
    end

W layout dopisujemy w znaczniku *HEAD*:

    :::html_rails app/views/layouts/application.html.erb
    <%= auto_discovery_link_tag(:atom, fortunes_path(:atom)) %>


## Przechodzimy z Prototype na jQuery

Kopiujemy do katalogu *public/javascripts* plik *rails.js* z:

    http://github.com/rails/jquery-ujs

zmienając jego nazwę na *jquery.rails.js*.

Zmieniamy w layoucie wiersz z *javascript_include_tag* na:

    :::html_rails app/views/layouts/application.html.erb
    <%= javascript_include_tag
      "http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js",
      "jquery.rails.js" %>

i usuwamy z katalogu *public/javascripts* następujące pliki:
*controls.js*, *dragdrop.js*, *effects.js*, *prototype.js* i *rails.js*.

Zamiast zręcznie ręcznie zmieniać źródła możemy skorzystać z generatora
który zrobi to za nas.

Dopisujemy do *Gemfile*:

    :::ruby Gemfile
    group :development do
      # automate using jQuery: http://github.com/indirect/jquery-rails
      gem 'jquery-rails'
    end

Po wykonaniu polecenia

    rails generate jquery:install


## Dodajemy wyszukiwanie (AJAX)

Co oznacza „unobtrusive Javascript”?

Do szablonu *index.html.erb* dodamy formularz do wyszukiwania
fortunek. Wyszukane fortunki umieścimy w elemencie *DIV*.
Dlaczego potrzebujemy pojemnika na fortunki?

Przy okazji zrobimy refaktoryzację kodu:

    :::html_rails app/views/fortunes/index.html.erb
    <% title "Wszystkie fortunki" %>
    <%= form_tag fortunes_path, :method => :get, :remote => true do %>
      <p>
        <%= text_field_tag :search, params[:search] %>
        <%= submit_tag "Search", :name => nil %>
      </p>
    <% end %>
    <div id="fortunes">
      <%= render @fortunes %>
    </div>
    <p><%= link_to "New Fortune", new_fortune_path %></p>

W szablonie częściowym *_fortune.html.erb* nie potrzebujemy pętli
(dlaczego?):

    :::html_rails app/views/fortunes/_fortune.html.erb
    <p>
     <%= fortune.body %>
     <%= link_to "Show", fortune_path(fortune) %> |
     <%= link_to "Edit", edit_fortune_path(fortune) %> |
     <%= link_to "Delete", fortune_path(fortune), :confirm => "Are you sure?", :method => :delete %>
    </p>

Oto fragment źródła strony wygenerowanej z powyższego szablonu:

    :::html_rails
    <form action="/fortunes" data-remote="true" method="get">

Do czego służą atrybuty *data-\** ?
Czy elementy z takimi atrybutami się walidują?

Wchodzimy na stronę:

    http://localhost:3000/

Pozostało napisać szablon *index.js.erb*.
Co oznacza rozszerzenie *.js.erb*?

    :::jquery_javascript app/views/fortunes/index.js.erb
    $("#fortunes").html("<%= escape_javascript(render(@fortunes)) %>");

Pytanie: co powinniśmy dopisać / zmienić w kontrolerze
*FortunesController*? Jakąś metodę? Jeśli tak, to jaką?

Odpowiedzi. Zmieniamy kod metody *index*

    :::ruby app/controllers/fortunes_controller.rb
    def index
      @fortunes = Fortune.search(params[:search]).order("created_at desc")
      respond_with @fortunes
    end

A użytą powyżej metodę klasową *search* implementujemy w modelu
*Fortune* tak:

    :::ruby app/models/fortune.rb
    def self.search(query)
      where("body like ?", "%#{query}%")
    end

Metoda *search* jest wykonywana zawsze po wejściu na stronę *index*,
nawet jak nic nie wyszukujemy. Dlaczego nie generuje ona błędu?
Dlaczego wyszukiwanie działa?


## Dodajemy tagowanie

Tagowanie dodamy, korzystając z gemu
[acts-as-taggable-on](http://github.com/mbleigh/acts-as-taggable-on).

Korzystając z tego co napisano w *README.rdoc* dokonujemy
następujących zmian w aplikacji.

Zgodnie z README ze strony git projektu, dopisujemy gem do pliku *Gemfile*:

    :::ruby Gemfile
    gem 'acts-as-taggable-on'

i instalujemy go w systemie za pomocą:

    bundle install

Po instalacji wykonujemy polecenia:

    rails generate acts_as_taggable_on:migration
    rake db:migrate

### Zmiany w kodzie

Do modelu dopisujemy:

    :::ruby app/models/fortune.rb
    class Fortune < ActiveRecord::Base
      acts_as_taggable_on :tags
      ActsAsTaggableOn::TagList.delimiter = " "

Przy okazji, zmieniamy domyślny znak do oddzielania tagów z przecinka
na spację.

W formularzu zmieniamy i dopisujemy:

    :::html_rails app/views/fortunes/_form.html.erb
    <p>Body:<br/><%= f.text_area :body, :cols => 60, :rows => 8 %></p>
    <p><%= f.label :tag_list %>: <%= f.text_field :tag_list, :size => 60 %></p>

a w widoku *index*:

    :::html_rails app/views/fortunes/index.html.erb
    <p>Tags: <%= fortune.tag_list %></p>

Pozsotaje jeszcze dopisać wyświetlanie tagów tu i ówdzie (gdzie?).


### Chmurka tagów

Aby utworzyć chmurkę tagów dopisujemy do widoku *index*:

    :::html_rails app/views/fortunes/index.html.erb
    <% tag_cloud(@tags, %w(css1 css2 css3 css4)) do |tag, css_class| %>
      <%= link_to tag.name, LINK_DO_CZEGO?, :class => css_class %>
    <% end %>

Aby ten kod zadziałał musimy zdefiniować zmienną *@tags*, wczytać kod
metody pomocniczej *tag_cloud*, wystylizować chmurkę tagów oraz
podmienić *LINK_DO_CZEGO?* na coś sensownego.

Na razie możemy wypróbować coś takiego:

    :::html_rails
    <% tag_cloud(@tags, %w(css1 css2 css3 css4)) do |tag, css_class| %>
      <%= link_to tag.name, fortunes_path, :class => css_class %>
      <%= debug(tag) %>
    <% end %>

Jakieś rozwiązanie jest w następnej sekcji.

W metodzie *index* kontrolera *FortunesController* przed dopisujemy:

    :::ruby app/controllers/fortunes_controller.rb
    @tags = Fortune.tag_counts
    respond_with @fortunes  # bez zmian

W pliku na metody pomocnicze dopisujemy;

    :::ruby app/helpers/fortunes_helper.rb
    module FortunesHelper
      include ActsAsTaggableOn::TagsHelper
    end

Na koniec dopisujemy do pliku CSS aplikacji:

    :::css public/stylesheets/application.css
    .css1 { font-size: 1.0em; }
    .css2 { font-size: 1.2em; }
    .css3 { font-size: 1.4em; }
    .css4 { font-size: 1.6em; }


### Dodajemy własne akcje do REST

Mając chmurkę z tagami, wypadałoby olinkować tagi tak, aby
po kliknięciu na nazwę wyświetliły się fortunki otagowane
tą nazwą.

Spróbujemy zrobić to tak. Zaczniemy od routingu:

    :::ruby config/routes.rb
    resources :fortunes do
      collection do
        get :tags
      end
    end

Sprawdzamy routing:

    rake routes

i widzimy, że mamy dodatkowo:

    tags_fortunes GET /fortunes/tags {:action=>"tags", :controller=>"fortunes"}

Teraz dopisujemy co trzeba w kontrolerze (plus mała refaktoryzacja; jaka?):

    :::ruby app/controllers/fortunes_controller.rb
    before_filter :only => [:index, :tags] do
      @tags = Fortune.tag_counts  # for tag clouds
    end

    def index
      @fortunes = Fortune.search(params[:search]).order("created_at desc")
      respond_with @fortunes
    end

    def tags
      @fortunes = Fortune.tagged_with(params[:name])
      render 'index'
    end

Na koniec podmieniamy `LINK_DO_CZEGO?` powyżej:

    :::ruby
    <%= link_to tag.name, tags_fortunes_path(:name=>tag.name), :class => css_class %>

Przyjrzeć się jak to działa!


## Dodajemy komentarze do fortunek

<blockquote>
 <p>Software is invisible and <b>unvisualizable</b>. Geometric abstractions are
  powerful tools. The floor plan of a building helps both architect and
  client evaluate spaces, traffic flows, views. Contradictions and
  omissions become obvious.</p>
 <p>In spite of progress in restricting and simplifying the structures of
  software, they remain inherently unvisualizable, and thus do not
  permit the mind to use some of its most powerful conceptual
  tools. This lack not only impedes the process of design within one
  mind, it severely hinders communication among minds.</p>
 <p class="author">— Frederick P. Brooks, Jr.</p>
</blockquote>

Dodajemy do każdej fortunki możliwość dopisywania komentarzy.

Zaczynamy od wygenerowania rusztowania dla zasobu *Comment* oraz
wykonania migracji:

    rails g resource Comment fortune:references \
        author:string body:string
    rake db:migrate

Zagnieżdżamy zasoby i sprawdzamy jak to zmienia routing:

    :::ruby
    resources :fortunes do
      resources :comments
      collection do
        get :tags
      end
    end

Po tej zmianie polecenie

    rake routes

wypisuje nowy routing:

                         GET    /fortunes/:fortune_id/comments          {:action=>"index",   :controller=>"comments"}
        fortune_comments POST   /fortunes/:fortune_id/comments          {:action=>"create",  :controller=>"comments"}
     new_fortune_comment GET    /fortunes/:fortune_id/comments/new      {:action=>"new",     :controller=>"comments"}
                         GET    /fortunes/:fortune_id/comments/:id      {:action=>"show",    :controller=>"comments"}
                         PUT    /fortunes/:fortune_id/comments/:id      {:action=>"update",  :controller=>"comments"}
         fortune_comment DELETE /fortunes/:fortune_id/comments/:id      {:action=>"destroy", :controller=>"comments"}
    edit_fortune_comment GET    /fortunes/:fortune_id/comments/:id/edit {:action=>"edit",    :controller=>"comments"}


oraz stary routing, który też obowiązuje:

    tags_fortunes GET    /fortunes/tags     {:action=>"tags",    :controller=>"fortunes"}
                  GET    /fortunes          {:action=>"index",   :controller=>"fortunes"}
         fortunes POST   /fortunes          {:action=>"create",  :controller=>"fortunes"}
      new_fortune GET    /fortunes/new      {:action=>"new",     :controller=>"fortunes"}
                  GET    /fortunes/:id      {:action=>"show",    :controller=>"fortunes"}
                  PUT    /fortunes/:id      {:action=>"update",  :controller=>"fortunes"}
          fortune DELETE /fortunes/:id      {:action=>"destroy", :controller=>"fortunes"}
     edit_fortune GET    /fortunes/:id/edit {:action=>"edit",    :controller=>"fortunes"}

             root        /                  {:controller=>"fortunes", :action=>"index"}

Przechodzimy do modelu *Comment*, gdzie znajdujemy dopisane powiązanie:

    :::ruby app/models/comment.rb
    class Comment < ActiveRecord::Base
      belongs_to :fortune
    end

Przechodzimy do modelu *Fortune*, gdzie dopisujemy drugą stronę powiązania:

    :::ruby app/models/fortune.rb
    class Fortune < ActiveRecord::Base
      has_many :comments, :dependent => :destroy
      ...

Nie zapominamy o migracji:

    rake db:migrate

Jeśli na konsoli uruchomimy kod:

    :::ruby
    Fortune.first.comments  #=> []

to przekonamy się, że komentarze pierwszej fortunki tworzą pustą tablicę.
Aby dodać komentarz możemy postąpić tak:

    :::ruby
    Fortune.first.comments << Comment.new(:author=>"Ja", :body=>"Fajne!")


### Gdzie wyświetlać komentarze?

Komentarze dla konkretnej fortunki wypiszemy w jej widoku *show*
(**inne propozycje?**). Dopiszemy taki kod:

    :::html_rails app/views/fortunes/show.html.erb
    <% if @fortune.comments.any? %>
      <h2>Komentarze</h2>
      <% @fortune.comments.each do |comment| %>
       <p>Autor:<br><%= comment.author %></p>
       <div class="comment">
         <b>Body:</b> <%= comment.body %>
       </div>
       <%= link_to "Delete", [@fortune, comment], :confirm => "Are you sure?", :method => :delete %>
      <% end %>
    <% end %>

Jakie nowe rzeczy pojawiły się powyższym kodzie?


### Gdzie wpisywać nowe komentarze?

Najwygodniej byłoby dodać też formularz do widoku *show*
(**dlaczego?**):

    :::html_rails app/views/fortunes/show.html.erb
    <h2>Dodaj komentarz</h2>
    <%= form_for [@fortune, @fortune.comments.build] do |f| %>
      <%= f.error_messages %>
      <p>
        <%= f.label :author, "Author" %><br>
        <%= f.text_field :author %>
      </p>
      <p><%= f.text_area :body, :rows => 4 %></p>
      <p><%= f.submit %></p>
    <% end %>

Nowe rzeczy w kodzie? Dlaczego taki pokrętny kod: **@fortune.comments.build**?
Czy samo *Comment.new* nie wystarczy?
Gdzie jest zdefiniowana metoda *error_messages*?


### Tworzenie i usuwanie komentarzy

W pustym *CommentsController* wpisujemy:

    :::ruby app/controllers/comments_controller.rb
    class CommentsController < ApplicationController
      before_filter do
        @fortune = Fortune.find params[:fortune_id]
      end

      def new
        respond_with @comment
      end

      def create
        @comment = @fortune.comments.new params[:comment]
        @comment.save
        respond_with @comment, :location => fortunes_url
      end

      def destroy
        @comment = @fortune.comments.find params[:id]
        @comment.destroy
        respond_with @fortune
      end
    end

Dodajemy nowy widok *new* dla komentarzy (dlaczego?):

    :::html_rails app/views/comments/new.html.erb
    <% title "Nowy komentarz" %>
    <%= render 'form' %>
    <%= link_to 'Back', fortunes_path %>


## Refaktoryzacja widoku „show” dla fortunek

Tworzymy dwa szablony częściowe dla komentarzy: *_form.html.erb*:

    :::html_rails app/views/comments/_form.html.erb
    <%= form_for [@fortune, @fortune.comments.build] do |f| %>
      <%= f.error_messages %>
      <p>
        <%= f.label :author, "Author" %><br>
        <%= f.text_field :author %>
      </p>
      <p><%= f.text_area :body, :rows => 4 %></p>
      <p><%= f.submit %></p>
    <% end %>

oraz *_comment.html.erb*::

    :::html_rails app/views/comments/_comment.html.erb
    <p>Autor:<br><%= comment.author %></p>
    <div class="comment">
      <b>Body:</b> <%= comment.body %>
    </div>
    <%= link_to "Delete", [comment.fortune, comment], :confirm => "Are you sure?", :method => :delete %>

Interesujący kod w *link_to* powyżej!

Poprawiamy kod widoku *show*, tak aby korzystał z tych szablonów:

    :::html_rails app/views/fortunes/show.html.erb
    <h2>Dodaj komentarz</h2>
    <%= render 'comments/form' %>

    <% if @fortune.comments.any? %>
      <h2>Komentarze</h2>
      <%= render @fortune.comments %>
    <% end %>


## I18N: error_messages

Kod wygenerowany przez generator nifty:layout:

    :::ruby app/helpers/error_messages_helper.rb
    module ErrorMessagesHelper
      # Render error messages for the given objects. The :message and :header_message options are allowed.
      def error_messages_for(*objects)
        options = objects.extract_options!
        options[:header_message] ||= "Invalid Fields"
        options[:message] ||= "Correct the following errors and try again."
        ...

Jak to zlokalizować? Jaki dodać prefix? Zobacz
[Support Rails built in i18n system for easy translations](http://github.com/ryanb/nifty-generators/issues#issue/22).

Może tak:

    :::ruby
    options[:header_message] ||= I18n.t(errors.template.header_message), :default => "Invalid Fields"
    options[:message] ||= I18n.t(errors.template.message), :default => "Correct the following errors and try again."

Plik z polskim tłumaczeniem:

    errors:
      template:
        header_message:
          "Nieprawidłowo wypełniony formularz"
        message:
          "Popraw poniższe błędy i spróbuj jeszcze raz:"


# Szlifowanie kodu

1\. Fortunka jest olinkowana byle jak, brakuje odsyłaczy etc.
Znależć wszystkie te miejsca i poprawić kod.

2\. Dopisać logowanie via *authenticate_or_request_with_http_basic* tak jak to jest
opisane w samouczku [Getting Started with Rails](http://edgeguides.rubyonrails.org/getting_started.html).


## Dodać autentykacja

* [Introducing Devise](http://asciicasts.com/episodes/209-introducing-devise).
* [Customizing Devise](http://asciicasts.com/episodes/210-customizing-devise).


## Przypominanie hasła – korzystamy z poczty

Konfiguracja:

    :::yaml config/mailer_config.yml
    development:
      domain: localhost:3000
      host: localhost:3000
      address: smtp.gmail.com
      port: 587
      user_name: <login>
      password: <password>
      authentication: plain

    test:
      domain: localhost:3000

    production:
      domain: localhost:3000
      host: sigma.ug.edu.pl:3000
      address: inf.ug.edu.pl
      port: 25
      user_name: <login>
      password: <password>
      authentication: login

**Dlaczego zmienne wpisujemy w osobnym pliku?**

Używamy stałej globalnej:

    :::ruby config/initializers/load_mailer_config.rb
    raw_config = File.read("#{Rails.root}/config/mailer_config.yml")
    MAILER_CONFIG = YAML.load(raw_config)[Rails.env].symbolize_keys

Konfigurujemy SMTP:

    :::ruby config/initializers/setup_mail.rb
    ActionMailer::Base.smtp_settings = {
      :address              => MAILER_CONFIG[:address],
      :port                 => MAILER_CONFIG[:port],
      :domain               => MAILER_CONFIG[:domain],
      :user_name            => MAILER_CONFIG[:user_name],
      :password             => MAILER_CONFIG[:password],
      :authentication       => MAILER_CONFIG[:authentication],
      :enable_starttls_auto => true
    }
    ActionMailer::Base.default_url_options[:host] = MAILER_CONFIG[:host]

Wygodne w development:

    :::ruby lib/development_mail_interceptor.rb
    class FortuneMailInterceptor
      def self.delivering_email(message)
        message.subject = "[#{message.to}] #{message.subject}"
        message.to = "matwb@ug.edu.pl"
      end
    end
    ActionMailer::Base.register_interceptor(FortuneMailInterceptor) if Rails.env.development?

Musimy jeszcze dodać katalog *lib* do ścieżki wyszukiwania:

    :::ruby config/application.rb
    module Fortunka
      class Application < Rails::Application
        # Custom directories with classes and modules you want to be autoloadable.
        # config.autoload_paths += %W(#{config.root}/extras)
        config.autoload_paths += %W(#{config.root}/lib)


## Różne

* Co to jest „unobtrusive Javascript”?
  [jQuery UJS dla Rails3](http://github.com/rails/jquery-ujs).
* Zajaxowana Fortunka: sklonować repozytorium git *hello/rails3-ajax*.
  Jak to działa? Źródło
  [Creating a 100% ajax CRUD using rails 3 and unobtrusive javascript](http://stjhimy.com/posts/7).
* Bundler. Gemfile examples
  [Featuring Bundler, Cucumber, RVM, Postgres, on Ruby-1.8.7](http://gist.github.com/416372)
* [Rails3 blog w 20 minut] [rails3 blog]


[rvm]: http://rvm.beginrescueend.com/ "Ruby Version Manager"
[rails3 blog]: http://www.railsdispatch.com/posts/rails-3-makes-life-better "Rails3 blog w 20 minut"
